import sys
import random
import hashlib
#from scapy.all import *

imports = ['argparse', 'requests', 'socket', 'paramiko']
args = 0

for i in imports:
    try:
        exec("import {module}".format(module=i))
    except ModuleNotFoundError as e:
        print(e)
        print("Install missing module to run this script")
        sys.exit()

def sub_enumerate(arg):
    subs = wordlist(args.wordlist).splitlines()
    loading = "|/-\\-"
    n = 0

    for sub in subs:
        sub_domains = f"http://{sub}.{arg}" 
        try:
            requests.get(sub_domains)
        except requests.ConnectionError:
            sys.stdout.write("\rSearching subdomains " + loading[random.randint(0, 4) % len(loading)])
            sys.stdout.flush()
            pass
        else:
            print("\rValid domain: ",sub_domains)
            n+=1 
    print(f"\rFound domains: {n}")
    
def dir_enumerate(arg):
    dirs = wordlist(args.wordlist).splitlines()
    loading = "|/-\\-"
    n = 0

    for dir in dirs:
        dir_enum = f"http://{arg}/{dir}.html" 
        req = requests.get(dir_enum)
        if req.status_code==404:
            sys.stdout.write("\rSearching directories " + loading[random.randint(0, 4) % len(loading)])
            sys.stdout.flush()
        elif req.status_code==403:
            print(f'Access to {dir} is forbidden')
            print('')
            n+=1
        else:
            print("\rValid directory:" ,dir_enum)
            n+=1
    print(f"\rFound directories: {n}")

def host_scan(arg):
    interface = "eth0"
    ip_range = arg
    broadcastMac = "ff:ff:ff:ff:ff:ff"

    packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range) 

    ans, unans = srp(packet, timeout =2, iface=interface, inter=0.1)

    for send,receive in ans:
            print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))

def port_scan(ip):
    open_ports = []
    top_port = 1024
    if args.port:
        top_port = int(args.port)
    ports = range(1, top_port)
    n=0

    for port in ports: 
        sys.stdout.flush() 
        loading = "|/-\\-"
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
        sock.settimeout(0.1) 
        r = sock.connect_ex((ip, port)) 
        if r == 0: 
            open_ports.append(port)
            n+=1
        sock.close() 
        sys.stdout.write("\rSearching ports " + loading[random.randint(0, 4) % len(loading)])
        sys.stdout.flush()    

    if open_ports: 
        print (f"\rThere are {n} open ports: ") 
        print (sorted(open_ports)) 
    else: 
        print ("\rNo open ports      ")

def cracker(hash):
    passwords = wordlist(args.wordlist).splitlines()

    for line in passwords:
        hash_ob = hashlib.md5(line.strip().encode())
        hashed_pass = hash_ob.hexdigest()
        print(line)
        if hashed_pass == hash:
            print('Password found: ' + line.strip())
            sys.exit()
    print("No passwords found")

def ssh_brute(target):
    if '@' in target:
        target = target.split('@')
        target_ip = target[1]
        target_user = target[0]
        passwords = wordlist(args.wordlist).splitlines()
        n = 0

        for line in passwords:
            password = line.strip()
            
            try:
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                code = 0

                try:
                    ssh.connect(target_ip, port=22, username=target_user, password=password)
                except paramiko.AuthenticationException:
                    code = 1
                ssh.close()

                if code == 0:
                    print('Success. Password found: '+ password)
                    sys.exit()
                elif code == 1: 
                    print('Attack failed')
        
            except Exception as e:
                if n < 3:
                    print(e)
                    n+=1
                else:
                    sys.exit()
    else:
        print("Keep proper format while specifying target: <user>@<ip>")

def wordlist(wordlist):
        try:
            with open(wordlist, 'r') as file:
                wordlist = file.read()
        except TypeError:
            print("You need to specify wordlist to use.")
            sys.exit()
        except FileNotFoundError:
            print("Wordlist not found. Check filename, path or extension.")
            sys.exit()
        return wordlist

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-w', '--wordlist', help='passing txt wordlist for enumeration.')
    parser.add_argument('-e', '--enum', help='subdomain enumeration')
    parser.add_argument('-d', '--dir', help='directory enumeration')
    parser.add_argument('-hs', '--hosts', help='network hosts arp scan')
    parser.add_argument('-ps', '--ports', help='target open ports scan')
    parser.add_argument('-p', '--port', help='port scan limit. By default only scans known ports.')
    parser.add_argument('-hc', '--hcrack', help='hashes given password with MD5 and checks it against given list.')
    parser.add_argument('-s', '--sbrute', help='brute forcing ssh protocols. Format: <user>@<ip>')
    args = parser.parse_args()
    print(args)

    if args.enum:
        sub_enumerate(args.enum)
    elif args.dir:
        dir_enumerate(args.dir)
    elif args.hosts:
        host_scan(args.hosts)
    elif args.ports:
        port_scan(args.ports)
    elif args.hashcracker:
        cracker(args.hashcracker)
    elif args.sshbrute:
        ssh_brute(args.sshbrute)
    sys.exit()

if __name__=='__main__':
    if sys.argv[1]:
        main()
    else:
        sys.exit()